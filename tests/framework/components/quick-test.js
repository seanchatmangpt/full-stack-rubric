/**
 * Ultra-efficient one-liner component testers with smart defaults
 * @fileoverview Quick component testing utilities for Nuxt components
 */

import { mount, shallowMount } from '@vue/test-utils'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { createNuxtApp } from '#app'

/**
 * @typedef {Object} QuickTestOptions
 * @property {boolean} shallow - Use shallow mounting (default: false)
 * @property {Object} props - Props to pass to component
 * @property {Object} slots - Slots to render
 * @property {Object} global - Global config for mounting
 * @property {boolean} autoProps - Auto-generate props from component definition
 * @property {Array<string>} events - Events to test automatically
 * @property {boolean} a11y - Run accessibility tests (default: true)
 * @property {Object} mocks - Nuxt composables to mock
 */

/**
 * One-liner component test with smart defaults
 * @param {string} name - Test name
 * @param {Object} component - Vue component
 * @param {QuickTestOptions} options - Test options
 * @returns {Object} Test wrapper with utilities
 */
export const quickTest = (name, component, options = {}) => {
  const {
    shallow = false,
    props = {},
    slots = {},
    global = {},
    autoProps = true,
    events = [],
    a11y = true,
    mocks = {}
  } = options

  return describe(name, () => {
    let wrapper
    let mockNuxt

    beforeEach(async () => {
      // Mock Nuxt context
      mockNuxt = {
        $router: { push: vi.fn(), replace: vi.fn(), go: vi.fn() },
        $route: { params: {}, query: {}, path: '/', name: 'index' },
        $nuxt: { context: {} },
        ...mocks
      }

      const mountFn = shallow ? shallowMount : mount
      const autoGeneratedProps = autoProps ? generateSmartProps(component) : {}
      
      wrapper = mountFn(component, {
        props: { ...autoGeneratedProps, ...props },
        slots,
        global: {
          mocks: mockNuxt,
          stubs: {
            NuxtLink: true,
            NuxtPage: true,
            ClientOnly: true,
            ...global.stubs
          },
          ...global
        }
      })
    })

    // Basic rendering test
    it('renders without errors', () => {
      expect(wrapper.exists()).toBe(true)
      expect(wrapper.html()).toBeTruthy()
    })

    // Props validation test
    it('validates props correctly', async () => {
      const componentProps = component.props || {}
      
      for (const [propName, propConfig] of Object.entries(componentProps)) {
        if (propConfig.required) {
          expect(wrapper.props(propName)).toBeDefined()
        }
        
        if (propConfig.validator) {
          const propValue = wrapper.props(propName)
          if (propValue !== undefined) {
            expect(propConfig.validator(propValue)).toBe(true)
          }
        }
      }
    })

    // Event testing
    if (events.length > 0) {
      it('emits events correctly', async () => {
        for (const eventName of events) {
          const trigger = wrapper.find(`[data-testid="${eventName}-trigger"]`)
          if (trigger.exists()) {
            await trigger.trigger('click')
            expect(wrapper.emitted(eventName)).toBeTruthy()
          }
        }
      })
    }

    // Accessibility testing
    if (a11y) {
      it('meets accessibility standards', () => {
        const element = wrapper.element
        
        // Check for aria-labels on interactive elements
        const interactiveElements = element.querySelectorAll('button, a, input, select, textarea')
        interactiveElements.forEach(el => {
          const hasLabel = el.getAttribute('aria-label') || 
                          el.getAttribute('aria-labelledby') || 
                          el.textContent.trim()
          expect(hasLabel).toBeTruthy()
        })

        // Check for alt text on images
        const images = element.querySelectorAll('img')
        images.forEach(img => {
          expect(img.getAttribute('alt')).toBeTruthy()
        })
      })
    }

    // Return wrapper for custom tests
    return {
      wrapper,
      mockNuxt,
      async rerender(newProps = {}) {
        await wrapper.setProps({ ...wrapper.props(), ...newProps })
      },
      async emitEvent(eventName, payload) {
        wrapper.vm.$emit(eventName, payload)
        await wrapper.vm.$nextTick()
      },
      getByTestId(testId) {
        return wrapper.find(`[data-testid="${testId}"]`)
      },
      getAllByTestId(testId) {
        return wrapper.findAll(`[data-testid="${testId}"]`)
      }
    }
  })
}

/**
 * Generate smart default props based on component definition
 * @param {Object} component - Vue component
 * @returns {Object} Generated props
 */
const generateSmartProps = (component) => {
  const props = {}
  const componentProps = component.props || {}

  for (const [propName, propConfig] of Object.entries(componentProps)) {
    if (typeof propConfig === 'function') {
      // Constructor function
      props[propName] = getDefaultValueForType(propConfig)
    } else if (typeof propConfig === 'object') {
      if (propConfig.default !== undefined) {
        props[propName] = typeof propConfig.default === 'function' 
          ? propConfig.default() 
          : propConfig.default
      } else if (propConfig.type) {
        props[propName] = getDefaultValueForType(propConfig.type)
      }
    }
  }

  return props
}

/**
 * Get default value for prop type
 * @param {Function} type - Prop type constructor
 * @returns {*} Default value
 */
const getDefaultValueForType = (type) => {
  const typeMap = {
    String: 'test-string',
    Number: 42,
    Boolean: true,
    Array: [],
    Object: {},
    Date: new Date(),
    Function: vi.fn()
  }

  return typeMap[type.name] || null
}

/**
 * Batch test multiple components with same options
 * @param {Array} components - Array of [name, component, options] tuples
 * @returns {Array} Test results
 */
export const batchTest = (components) => {
  return components.map(([name, component, options = {}]) => 
    quickTest(name, component, options)
  )
}

/**
 * Test component with multiple prop combinations
 * @param {string} name - Test suite name
 * @param {Object} component - Vue component
 * @param {Array} propCombinations - Array of prop objects to test
 * @returns {Object} Test suite
 */
export const propMatrix = (name, component, propCombinations) => {
  return describe(`${name} - Prop Matrix`, () => {
    propCombinations.forEach((props, index) => {
      quickTest(`Combination ${index + 1}`, component, { props })
    })
  })
}

/**
 * Responsive component testing
 * @param {string} name - Test name
 * @param {Object} component - Vue component
 * @param {Array} breakpoints - Screen widths to test
 * @returns {Object} Test suite
 */
export const responsiveTest = (name, component, breakpoints = [320, 768, 1024, 1200]) => {
  return describe(`${name} - Responsive`, () => {
    breakpoints.forEach(width => {
      it(`renders correctly at ${width}px`, () => {
        Object.defineProperty(window, 'innerWidth', {
          writable: true,
          configurable: true,
          value: width
        })
        
        const wrapper = mount(component)
        expect(wrapper.exists()).toBe(true)
        
        // Trigger resize event
        window.dispatchEvent(new Event('resize'))
      })
    })
  })
}

export default quickTest